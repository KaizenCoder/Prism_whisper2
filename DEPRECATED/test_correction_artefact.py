#!/usr/bin/env python3
"""
Test de Correction des Artefacts SuperWhisper2
Validation du syst√®me VAD et filtrage anti-hallucination
Phase 3 - RTX 3090 Performance + Correction Artefacts
"""

import os
import sys
import time
import threading
import logging
from datetime import datetime
from typing import List, Dict

# Configuration RTX 3090
os.environ['CUDA_VISIBLE_DEVICES'] = '1'  # RTX 3090 24GB
os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'

# Ajouter src au path  
current_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.join(current_dir, 'src')
sys.path.insert(0, src_dir)

from core.whisper_engine_v5 import SuperWhisper2EngineV5

class ArtifactCorrectionTest:
    """
    Test de validation de la correction des artefacts Whisper
    """
    
    def __init__(self):
        self.engine = None
        self.test_results = []
        self.hallucinations_detected = 0
        self.valid_transcriptions = 0
        self.total_chunks = 0
        
        # Configuration logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler(f'test_artifact_correction_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')
            ]
        )
        self.logger = logging.getLogger('ArtifactTest')
        
    def setup_engine(self) -> bool:
        """
        Initialisation Engine V5 avec corrections artefacts
        """
        try:
            self.logger.info("üöÄ Initialisation SuperWhisper2 Engine V5 avec correction artefacts...")
            
            self.engine = SuperWhisper2EngineV5()
            
            # Callback pour capturer les transcriptions
            def on_transcription(text: str):
                self.total_chunks += 1
                
                # V√©rifier si c'est une hallucination filtr√©e ou transcription valide
                if text and len(text.strip()) > 0:
                    self.valid_transcriptions += 1
                    self.logger.info(f"‚úÖ Transcription valide re√ßue: '{text[:50]}...'")
                    self.test_results.append({
                        'timestamp': time.time(),
                        'text': text,
                        'type': 'valid_transcription'
                    })
                else:
                    self.logger.warning("‚ö†Ô∏è Transcription vide re√ßue")
            
            self.engine.set_transcription_callback(on_transcription)
            
            # D√©marrer engine
            success = self.engine.start_engine()
            
            if success:
                self.logger.info("‚úÖ Engine V5 avec corrections artefacts initialis√©")
                status = self.engine.get_phase3_status()
                self.logger.info(f"üìä Optimisations: {status['optimizations_count']}/{status['total_optimizations']}")
                self.logger.info(f"üéÆ RTX 3090: {status['gpu_status']['vram_cache_gb']:.1f}GB VRAM")
                return True
            else:
                self.logger.error("‚ùå √âchec initialisation Engine V5")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå Erreur setup engine: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def test_vad_filtering(self) -> Dict:
        """
        Test du syst√®me VAD (Voice Activity Detection)
        """
        self.logger.info("üß™ Test VAD - Voice Activity Detection...")
        
        # Simuler diff√©rents types d'audio
        test_scenarios = [
            "Silence complet (pas de signal audio)",
            "Bruit de fond seul (ventilateur, √©lectronique)",
            "Audio avec vraie parole",
            "M√©lange parole + bruit"
        ]
        
        vad_results = {
            'scenarios_tested': len(test_scenarios),
            'vad_system_active': True,
            'expected_behavior': "Filtrage automatique des chunks sans parole"
        }
        
        self.logger.info("‚úÖ Test VAD simul√© - Syst√®me actif")
        for i, scenario in enumerate(test_scenarios, 1):
            self.logger.info(f"   {i}. {scenario}")
            
        return vad_results
    
    def test_hallucination_patterns(self) -> Dict:
        """
        Test de d√©tection des patterns d'hallucination
        """
        self.logger.info("üö´ Test d√©tection patterns d'hallucination...")
        
        # Patterns d'hallucination identifi√©s
        test_patterns = [
            "Sous-titres r√©alis√©s par la communaut√© d'Amara.org",
            "Merci d'avoir regard√© cette vid√©o!",
            "N'h√©sitez pas √† vous abonner",
            "Like et abonne-toi",
            "√Ä bient√¥t pour une nouvelle vid√©o"
        ]
        
        detected_patterns = 0
        
        for pattern in test_patterns:
            is_hallucination = self.engine._is_hallucination(pattern)
            if is_hallucination:
                detected_patterns += 1
                self.logger.info(f"‚úÖ Pattern d√©tect√©: '{pattern[:30]}...'")
            else:
                self.logger.warning(f"‚ùå Pattern non d√©tect√©: '{pattern[:30]}...'")
        
        detection_rate = (detected_patterns / len(test_patterns)) * 100
        
        result = {
            'total_patterns': len(test_patterns),
            'detected_patterns': detected_patterns,
            'detection_rate_percent': detection_rate,
            'status': 'PASSED' if detection_rate >= 80 else 'FAILED'
        }
        
        self.logger.info(f"üìä D√©tection patterns: {detected_patterns}/{len(test_patterns)} ({detection_rate:.1f}%)")
        return result
    
    def test_valid_transcription(self) -> Dict:
        """
        Test que les transcriptions valides passent le filtre
        """
        self.logger.info("‚úÖ Test transcriptions valides...")
        
        valid_texts = [
            "Bonjour, ceci est un test de validation.",
            "L'intelligence artificielle transforme notre monde.",
            "SuperWhisper2 fonctionne parfaitement avec RTX 3090.",
            "Je vais maintenant tester la transcription vocale.",
            "Les optimisations Phase 3 sont impressionnantes."
        ]
        
        passed_texts = 0
        
        for text in valid_texts:
            is_hallucination = self.engine._is_hallucination(text)
            if not is_hallucination:
                passed_texts += 1
                self.logger.info(f"‚úÖ Texte valide accept√©: '{text[:30]}...'")
            else:
                self.logger.warning(f"‚ùå Texte valide rejet√©: '{text[:30]}...'")
        
        pass_rate = (passed_texts / len(valid_texts)) * 100
        
        result = {
            'total_valid_texts': len(valid_texts),
            'passed_texts': passed_texts,
            'pass_rate_percent': pass_rate,
            'status': 'PASSED' if pass_rate >= 95 else 'FAILED'
        }
        
        self.logger.info(f"üìä Textes valides: {passed_texts}/{len(valid_texts)} ({pass_rate:.1f}%)")
        return result
    
    def run_realtime_test(self, duration_seconds=30) -> Dict:
        """
        Test en temps r√©el avec capture microphone
        """
        self.logger.info(f"üé§ Test temps r√©el {duration_seconds}s avec correction artefacts...")
        self.logger.info("=" * 60)
        self.logger.info("Commencez √† parler ou laissez en silence pour tester le filtrage VAD")
        
        start_time = time.time()
        initial_chunks = self.total_chunks
        initial_valid = self.valid_transcriptions
        
        # Attendre la dur√©e du test
        while time.time() - start_time < duration_seconds:
            time.sleep(1)
            elapsed = time.time() - start_time
            
            if int(elapsed) % 10 == 0:  # Log toutes les 10s
                chunks_processed = self.total_chunks - initial_chunks
                valid_received = self.valid_transcriptions - initial_valid
                self.logger.info(f"‚è±Ô∏è [{elapsed:.0f}s] Chunks: {chunks_processed}, Valides: {valid_received}")
        
        # R√©sultats finaux
        total_processed = self.total_chunks - initial_chunks
        total_valid = self.valid_transcriptions - initial_valid
        filtering_ratio = ((total_processed - total_valid) / total_processed * 100) if total_processed > 0 else 0
        
        result = {
            'test_duration_s': duration_seconds,
            'chunks_processed': total_processed,
            'valid_transcriptions': total_valid,
            'filtered_chunks': total_processed - total_valid,
            'filtering_ratio_percent': filtering_ratio,
            'avg_chunks_per_second': total_processed / duration_seconds if duration_seconds > 0 else 0
        }
        
        self.logger.info("=" * 60)
        self.logger.info(f"üìä R√©sultats test temps r√©el:")
        self.logger.info(f"   ‚Ä¢ Chunks trait√©s: {total_processed}")
        self.logger.info(f"   ‚Ä¢ Transcriptions valides: {total_valid}")
        self.logger.info(f"   ‚Ä¢ Chunks filtr√©s: {total_processed - total_valid}")
        self.logger.info(f"   ‚Ä¢ Taux filtrage: {filtering_ratio:.1f}%")
        
        return result
    
    def generate_report(self, test_results: Dict) -> None:
        """
        G√©n√©ration rapport complet
        """
        self.logger.info("\n" + "=" * 80)
        self.logger.info("üìã RAPPORT CORRECTION ARTEFACTS SUPERWHISPER2")
        self.logger.info("=" * 80)
        
        # Status g√©n√©ral
        all_tests_passed = all(
            result.get('status') == 'PASSED' 
            for result in test_results.values() 
            if 'status' in result
        )
        
        status_color = "‚úÖ" if all_tests_passed else "‚ùå"
        self.logger.info(f"{status_color} STATUS G√âN√âRAL: {'SUCC√àS' if all_tests_passed else '√âCHEC'}")
        
        # D√©tails par test
        for test_name, result in test_results.items():
            self.logger.info(f"\nüìä {test_name.upper()}:")
            for key, value in result.items():
                if key != 'status':
                    self.logger.info(f"   ‚Ä¢ {key}: {value}")
        
        # Recommandations
        self.logger.info("\nüí° RECOMMANDATIONS:")
        if all_tests_passed:
            self.logger.info("   ‚úÖ Syst√®me de correction artefacts op√©rationnel")
            self.logger.info("   ‚úÖ Pr√™t pour d√©ploiement production")
        else:
            self.logger.info("   ‚ö†Ô∏è Ajustements n√©cessaires avant production")
            
        # M√©triques performance
        if 'realtime_test' in test_results:
            rt = test_results['realtime_test']
            if rt['filtering_ratio_percent'] > 50:
                self.logger.info("   ‚úÖ Filtrage VAD efficace (>50% chunks filtr√©s)")
            elif rt['valid_transcriptions'] > 0:
                self.logger.info("   ‚úÖ Transcriptions valides d√©tect√©es correctement")
                
        self.logger.info("=" * 80)


def main():
    """
    Ex√©cution test correction artefacts
    """
    print("üß™ Test Correction Artefacts SuperWhisper2")
    print("Phase 3 - RTX 3090 + VAD + Anti-Hallucination")
    print("=" * 60)
    
    test = ArtifactCorrectionTest()
    
    # 1. Setup Engine
    if not test.setup_engine():
        print("‚ùå √âchec initialisation - Arr√™t test")
        return
    
    # 2. Tests de validation  
    test_results = {}
    
    try:
        # Test VAD
        test_results['vad_filtering'] = test.test_vad_filtering()
        
        # Test d√©tection hallucinations
        test_results['hallucination_detection'] = test.test_hallucination_patterns()
        
        # Test transcriptions valides
        test_results['valid_transcription'] = test.test_valid_transcription()
        
        # Test temps r√©el
        print("\nüé§ Test temps r√©el - Parlez ou restez silencieux pour 30s...")
        test_results['realtime_test'] = test.run_realtime_test(30)
        
        # Rapport final
        test.generate_report(test_results)
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Test interrompu par utilisateur")
    
    except Exception as e:
        print(f"\n‚ùå Erreur test: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        if test.engine:
            test.engine.stop_engine()
        print("\n‚úÖ Test termin√©")


if __name__ == "__main__":
    main() 